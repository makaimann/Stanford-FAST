# rdPtr maps to head
(cpempty = 0_1) -> (cpf_to_ll[rdPtr] = shared_fifo.ll.head[0_1]) & (ll_to_cpf[shared_fifo.ll.head[0_1]] = rdPtr)

# wrPtr maps to tail
(cpempty = 0_1) -> (cpf_to_ll[wrPtr] = shared_fifo.ll.tail[0_1]) & (ll_to_cpf[shared_fifo.ll.tail[0_1]] = wrPtr)

# identity maps for FIFO 0
(shared_fifo.count[0_1] >= 1_3) -> (ll_to_cpf[cpf_to_ll[rdPtr]] = rdPtr)
(shared_fifo.count[0_1] >= 2_3) -> (ll_to_cpf[cpf_to_ll[rdPtr+1]] = rdPtr+1)
(shared_fifo.count[0_1] >= 3_3) -> (ll_to_cpf[cpf_to_ll[rdPtr+2]] = rdPtr+2)
(shared_fifo.count[0_1] >= 4_3) -> (ll_to_cpf[cpf_to_ll[rdPtr+3]] = rdPtr+3)

# identity maps for free list
(free_list_count >= 1_3) -> (free_list_to_ptr[ptr_to_free_list[free_list_rdPtr]] = free_list_rdPtr)
(free_list_count >= 2_3) -> (free_list_to_ptr[ptr_to_free_list[free_list_rdPtr+1]] = free_list_rdPtr+1)
(free_list_count >= 3_3) -> (free_list_to_ptr[ptr_to_free_list[free_list_rdPtr+2]] = free_list_rdPtr+2)
(free_list_count >= 4_3) -> (free_list_to_ptr[ptr_to_free_list[free_list_rdPtr+3]] = free_list_rdPtr+3)

# next_ptr maps for FIFO 0
(shared_fifo.count[0_1] >= 2_3) -> (ll_to_cpf[next_ptr[cpf_to_ll[rdPtr]]] = rdPtr+1)
(shared_fifo.count[0_1] >= 3_3) -> (ll_to_cpf[next_ptr[cpf_to_ll[rdPtr+1]]] = rdPtr+2)
(shared_fifo.count[0_1] >= 4_3) -> (ll_to_cpf[next_ptr[cpf_to_ll[rdPtr+2]]] = rdPtr+3)

# next_ptr maps for free list
(free_list_count >= 2_3) -> free_list_to_ptr[next_ptr[ptr_to_free_list[free_list_rdPtr]]] = free_list_rdPtr+1
(free_list_count >= 3_3) -> free_list_to_ptr[next_ptr[ptr_to_free_list[free_list_rdPtr+1]]] = free_list_rdPtr+2
(free_list_count >= 4_3) -> free_list_to_ptr[next_ptr[ptr_to_free_list[free_list_rdPtr+2]]] = free_list_rdPtr+3

# will probably need distinctness of free list from existing allocated lists
# it's possible we could do this by stacking them in one array (but it would be expensive to maintain the invariants that the two are packed together in the array without overlapping or gaps)

# distinctness using UF
# identity maps for FIFO 0
(shared_fifo.count[0_1] >= 1_3) -> (f(cpf_to_ll[rdPtr]) = 0_3)
(shared_fifo.count[0_1] >= 2_3) -> (f(cpf_to_ll[rdPtr+1]) = 3_3)
(shared_fifo.count[0_1] >= 3_3) -> (f(cpf_to_ll[rdPtr+2]) = 3_3)
(shared_fifo.count[0_1] >= 4_3) -> (f(cpf_to_ll[rdPtr+3]) = 3_3)

# identity maps for free list
(free_list_count >= 1_3) -> (f(ptr_to_free_list[free_list_rdPtr]) = 4_3)
(free_list_count >= 2_3) -> (f(ptr_to_free_list[free_list_rdPtr+1]) = 5_3)
(free_list_count >= 3_3) -> (f(ptr_to_free_list[free_list_rdPtr+2]) = 6_3)
(free_list_count >= 4_3) -> (f(ptr_to_free_list[free_list_rdPtr+3]) = 7_3)
