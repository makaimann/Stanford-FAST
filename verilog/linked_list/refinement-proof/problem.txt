[GENERAL]
model_files: verif.vlist[top],reset.ets,init.ssts
abstract_clock: True
vcd: True
assume_if_true: True

[DEFAULT]
bmc_length: 5
solver_name: btor

[NEVER RESET DONE]
description: "Basic cover for reset sequence"
properties: !reset_done
verification: safety
expected: False

[DATA_INTEGRITY]
description: "Check data integrity with new scoreboard"
properties: prop_signal = 1_1
verification: safety
expected: Unknown
precondition: reset_done

[HEAD_MAPS_TO_POS_CNT]
description: "Check that the ghost state tracks correctly"
properties: ((empty[0:0] = 0_1) & (sb_en = 1_1) & (exited = 0_1)) ->
            ((F_head = 0_1) & (I_head = ptr_p_pos_cnt))
verification: safety
expected: Unknown
precondition: reset_done

[FREE_PTR_IN_OTHER]
description: "Check that free_ptr is tagged other unless the FIFOs are full"
properties: (full = 0_1) -> (F[free_ptr] = 1_1)
verification: safety
expected: Unknown
precondition: reset_done

[POPPED_HEAD_TAG]
description: "Check tag of popped_head"
properties: ((empty[0:0] = 0_1) & (pop_sel = 0_1)) -> (F[popped_head] = 0_1)
verification: safety
expected: Unknown
precondition: reset_done
bmc_length: 10

[FREE_PTR_NOT_POPPED_HEAD]
description: "Check that free_ptr can never equal popped_head if they're both valid"
properties: ((full = 0_1) & (empty[0:0] = 0_1) & (pop_sel = 0_1)) -> free_ptr != popped_head
verification: safety
expected: Unknown
precondition: reset_done
bmc_length: 10

# [COMPOSITIONAL]
# description: "Check properties compositionally"
# properties:
# verification: compsoitional
# generators: A=Random(shared_fifo.ll.free_list_head); B=Random(shared_fifo.ll.free_list_head)
# precondition: reset_done
# prove: True

# [COUNTS_MATCH]
# description: "Check that the counter logic is identical"
# properties: (count[0_1] = shared_fifo.ll.count[0_1]) & (count[1_1] = shared_fifo.ll.count[1_1])
# precondition: reset_done
# verification: safety
# expected: True
# prove: True

# [COUNTS_CONSISTENT_DEPTH]
# description: "Check that the counts add up to the depth"
# properties: (free_list_count + count[0_1] + count[1_1]) = depth
# precondition: reset_done
# verification: safety
# prove: True

# [COUNTS_CONSISTENT_TOTAL]
# description: "Check that the fifo counts equal the total count"
# # TODO  NEED TO ADAPT FOR MORE FIFOS
# properties: (count[0_1] + count[1_1]) = shared_fifo.ll.total_count
# precondition: reset_done
# verification: safety
# prove: True

# [COUNTERS_LTE_DEPTH]
# description: "Check that counters are less than or equal to the depth"
# properties: (count[0_1] <= depth) & (count[1_1] <= depth) & (free_list_count <= depth)
# precondition: reset_done
# verification: safety
# prove: True

# [REFINEMENT]
# description: "Check the refinement property"
# properties: refinement.txt
# precondition: reset_done
# verification: safety
# prove: True
